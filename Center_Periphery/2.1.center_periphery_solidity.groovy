/*
 * Script for the determination of the center and periphery of the samples according to their solidity.
 * The script creates the center and perifery regions and save the GeoJsons and the data of the annotations (Tumor, Center, Periphery).
 * The script will create sub-folders in the path of interest to store the files.
 * 
 * Check you have the Diameters of the tumor Annotation 
 * 
 * This script was generated by modifying a script by @PeteBankhead that is available at: https://petebankhead.github.io/qupath/scripts/2018/08/08/three-regions.html
 * 
 * Paper:
 * @authors:Mara Stoks and Isaac Vieco-Martí
 */


//Set path of the folder with QuPath project
def wd = " " 


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////NOT TO CHANGE FROM NOW ON//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//TUMOR_GJ: Defines the destination folder for the tumor GeoJson file
def pathOutput1 = wd + '/1.geojson_files_tumor'
mkdirs(pathOutput1)

//TUMOR_DATA: Defines the destination folder of the tumor area
def pathOutput2 = wd + '/2.data_area_tumor'
mkdirs(pathOutput2)

//CENTER: Defines the destination of the center GeoJson
def pathOutput3 = wd + '/3.geojson_files_center'
mkdirs(pathOutput3)

//PERIPHERY: Defines the destination of the periphery GeoJson
def pathOutput4 = wd + '/4.geojson_files_periphery'
mkdirs(pathOutput4)

//CENTER_PERIPHERY_DATA: Defines where center and periphery data go
def pathOutput5 = wd + '/5.data_area_center_periphery' 
mkdirs(pathOutput5)

//Get the main QuPath data structures
def imageData = getCurrentImageData()
def hierarchy = imageData.getHierarchy()
def server = imageData.getServer()
def analyzed_image = server.getMetadata().getName()
print("Image processing begins --> " + analyzed_image)


////////////////////////
//EXPORT TUMOR GEOJSON//
////////////////////////

selectObjectsByClassification("Tumor")
def name1 = getCurrentImageData().getServer().getMetadata().getName()
def path1 = pathOutput1 + "/" + name1 + ".geojson"
def annotations1 = hierarchy.getAnnotationObjects()
exportObjectsToGeoJson(annotations1, path1, "FEATURE_COLLECTION")   
print("GeoJson exported")


///////////////////////////////
///EXPORT AREA DATA OF TUMOR///
///////////////////////////////

def name_hg = getProjectEntry().getImageName() + '.txt'
path_hg = buildFilePath(pathOutput2, name_hg)
saveAnnotationMeasurements(path_hg)
print("Data exported")


//////////////////////////////////////////////////////////////
////////////CENTER-PERIPHERY ACCORDING TO SOLIDITY////////////
//////////////////////////////////////////////////////////////

//Dilation of annotation according to solidity or smallest diameter
import qupath.lib.gui.measure.ObservableMeasurementTableData
def ob = new ObservableMeasurementTableData();
ob.setImageData(getCurrentImageData(),  annotations1);
 
annotations1.each{
    solidity = ob.getNumericValue(it, "Solidity") 
    minDiam = ob.getNumericValue(it, "Min diameter µm")
    radio = minDiam/2
    
    //if the solidity is greater than 0.9, apply the circle approximation. If it is less, apply 1/4 of the radius.
    if( solidity > 0.9) {
        inner= ((2 - Math.sqrt(2))/2)*radio
        it.getMeasurementList().putMeasurement("inner", inner)
        print("Center-periphery criterion: Circle approximation, value of inner (in microns) --> " + inner) 
        } else{
        inner= radio/4
        it.getMeasurementList().putMeasurement("inner", inner)
        print("Center-periphery criterion: Approximation 1/4 of radius, value of inner (in microns) --> " + inner)
        } 
    }

//Import libraries
import org.locationtech.jts.geom.Geometry
import qupath.lib.common.GeneralTools
import qupath.lib.objects.PathObject
import qupath.lib.objects.PathObjects
import qupath.lib.roi.GeometryTools
import qupath.lib.roi.ROIs
import static qupath.lib.gui.scripting.QPEx.*

//Desired margin to buffer inwards
double expandMarginMicrons = inner

//Define the colors
def coloInnerMargin = getColorRGB(0, 0, 200)
def colorOuterMargin = getColorRGB(0, 200, 0)
def colorCentral = getColorRGB(0, 0, 0)

//Lock annotations
def lockAnnotations = true

//Calculation pixel size
def cal = server.getPixelCalibration()
if (!cal.hasPixelSizeMicrons()) {
  print 'We need the pixel size information here!'
  return
}
if (!GeneralTools.almostTheSame(cal.getPixelWidthMicrons(), cal.getPixelHeightMicrons(), 0.0001)) {
  print 'Warning! The pixel width & height are different; the average of both will be used'
}

//Select annotations
def annotations = getAnnotationObjects()
def selected =  annotations[0]
if (selected == null || !selected.isAnnotation()) {
  print 'Please select an annotation object!'
  return
}

//We need one selected annotation as a starting point; if we have other annotations, they will constrain the output
annotations.remove(selected)

//Extract the ROI & plane
def roiOriginal = selected.getROI()
def plane = roiOriginal.getImagePlane()

//If we have at most one other annotation, it represents the tissue
Geometry areaTissue
PathObject tissueAnnotation
if (annotations.isEmpty()) {
  areaTissue = ROIs.createRectangleROI(0, 0, server.getWidth(), server.getHeight(), plane).getGeometry()
} else if (annotations.size() == 1) {
  tissueAnnotation = annotations.get(0)
  areaTissue = tissueAnnotation.getROI().getGeometry()
} else {
  print 'Sorry, this script only support one selected annotation for the tumor region, and at most one other annotation to constrain the expansion'
  return
}

//Calculation of margin dilation
double expandPixels = expandMarginMicrons / cal.getAveragedPixelSizeMicrons()
def areaTumor = roiOriginal.getGeometry()

//Definition of central area
def geomCentral = areaTumor.buffer(-expandPixels)
geomCentral = geomCentral.intersection(areaTissue)
def roiCentral = GeometryTools.geometryToROI(geomCentral, plane)
def annotationCentral = PathObjects.createAnnotationObject(roiCentral)
annotationCentral.setName("Center")
annotationCentral.setColorRGB(colorCentral)
annotationCentral.each{it.setPathClass(getPathClass("Center"))}

//Definition of inner margin area
def geomInner = areaTumor
geomInner = geomInner.difference(geomCentral)
geomInner = geomInner.intersection(areaTissue)
def roiInner = GeometryTools.geometryToROI(geomInner, plane)
def annotationInner = PathObjects.createAnnotationObject(roiInner)
annotationInner.setName("Perifery margin")
annotationInner.setColorRGB(coloInnerMargin)
annotationInner.each{it.setPathClass(getPathClass("Perifery margin"))}

//Addition of generated annotations (center and inner margin
hierarchy.getSelectionModel().clearSelection()
hierarchy.removeObject(selected, true)
def annotationsToAdd = [ annotationInner, annotationCentral];
annotationsToAdd.each {it.setLocked(lockAnnotations)}
if (tissueAnnotation == null) {
  hierarchy.addPathObjects(annotationsToAdd)
} else {
  tissueAnnotation.addPathObjects(annotationsToAdd)
  hierarchy.fireHierarchyChangedEvent(this, tissueAnnotation)
  if (lockAnnotations)
    tissueAnnotation.setLocked(true)
}


///////////////////////////////
/////EXPORT CENTER GEOJSON/////
///////////////////////////////

selectObjectsByClassification("Center")
def annotations3 = getSelectedObjects()
def name3 = getCurrentImageData().getServer().getMetadata().getName()
def path3 = pathOutput3+ "/" + name3 + ".geojson"
exportObjectsToGeoJson(annotations3, path3, "FEATURE_COLLECTION")   
print("Center GeoJson exported")
resetSelection()


///////////////////////////////////
/////EXPORT PERIPHERY GEOJSON/////
//////////////////////////////////

selectObjectsByClassification("Perifery margin");
def annotations4 = getSelectedObjects()
def name4 = getCurrentImageData().getServer().getMetadata().getName()
def path4 = pathOutput4+ "/" + name4 + ".geojson"
exportObjectsToGeoJson(annotations4, path4, "FEATURE_COLLECTION")   
print("Periphery GeoJson exported")


////////////////////////////////////
////EXPORT CENTER-PERIPHERY DATA////
////////////////////////////////////

path_centro_periferia = buildFilePath(pathOutput5, name_hg)
saveAnnotationMeasurements(path_centro_periferia)
print("Data of center and periphery exported")
